'use strict'

const Canvas = require('canvas');
const fs = require('fs');
const DepthMapper = require('./depthMapper');

const render = function (
    width = 3, 
    height = 3, 
    depthMap = [[0.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 0.0]], 
    depthMapper = new DepthMapper(), 
    output = '', 
    colors = [
            [255, 255, 255, 255],
            [0, 0, 0, 255]
        ]
    ) {

    // check `width` and `height` property.
    if (!width) throw('Magicgram: width not set.');
    if (!height) throw('Magicgram: height not set');

    // use depthMap if provided, otherwise use depthMap generated by given depthMapper.
    var generatedDepthMap;
    if (depthMap) {
        generatedDepthMap = depthMap;
    } else if (depthMapper) {
        generatedDepthMap = depthMapper.generate(width, height);
    } else throw('Magicgram: no depthMap or depthMapper given');

    // convert hex colors to RGBa.
    for (var i = 0; i < colors.length; i++) {
        if (typeof colors[i] === "string") {
            colors[i] = hexToRGBa(colors[i]);
        }
    }

    const pixelData = generatePixelData(width, height, generatedDepthMap, colors);

    // output png image data to provided directory.
    renderToPNGImage(output, pixelData, width, height);
};

function generatePixelData(width, height, depthMap, colors) {
    /*
    * This algorithm was published in a paper authored by by Harold W.
    * Thimbleby, Stuart Inglis, and Ian H. Witten. The following code was
    * translated from the C code that was featured in the article.
    * http://www.cs.sfu.ca/CourseCentral/414/li/material/refs/SIRDS-Computer-94.pdf
    */

    var x, y, i, left, right, visible, t, zt, k, sep, z, pixelOffset, rgba,
        numColors = colors.length,
        same, // points to a pixel to the right
        dpi = 72, // assuming output of 72 dots per inch
        eyeSep = Math.round(2.5 * dpi), // eye separation assumed to be 2.5 inches
        mu = (1 / 3), // depth of field (fraction of viewing distance)
        pixels = new Uint8ClampedArray(width * height * 4);

    // for each row
    for (y = 0; y < height; y++) {
        // max image width (for Uint16Array) is 65536
        same = new Uint16Array(width); // points to a pixel to the right

        for (x = 0; x < width; x++) {
            same[x] = x; // each pixel is initially linked with itself
        }

        // for each column
        for (x = 0; x < width; x++) {
            z = depthMap[y][x];

            // stereo separation corresponding to z
            sep = Math.round((1 - (mu * z)) * eyeSep / (2 - (mu * z)));

            // x-values corresponding to left and right eyes
            left = Math.round(x - ((sep + (sep & y & 1)) / 2));
            right = left + sep;

            if (0 <= left && right < width) {

                // remove hidden surfaces
                t = 1;
                do {
                    zt = z + (2 * (2 - (mu * z)) * t / (mu * eyeSep));
                    visible = (depthMap[y][x-t] < zt) && (depthMap[y][x+t] < zt); // false if obscured
                    t++;
                } while (visible && zt < 1);

                if (visible) {
                    // record that left and right pixels are the same
                    for (k = same[left]; k !== left && k !== right; k = same[left]) {
                        if (k < right) {
                            left = k;
                        } else {
                            left = right;
                            right = k;
                        }
                    }
                    same[left] = right;
                }
            }
        }

        for (x = (width - 1); x >= 0; x--) {
            pixelOffset = (y * width * 4) + (x * 4);
            if (same[x] === x) {
                // set random color
                rgba = colors[Math.floor(Math.random() * numColors)];
                for (i = 0; i < 4; i++) {
                    pixels[pixelOffset + i] = rgba[i];
                }
            } else {
                // constrained pixel, obey constraint
                pixelOffset = (y * width * 4) + (x * 4);
                for (i = 0; i < 4; i++) {
                    pixels[pixelOffset + i] = pixels[(y * width * 4) + (same[x] * 4) + i];
                }
            }
        }
    }

    return pixels;
}

function renderToPNGImage(output, pixelData, width, height) {
    const canvas = Canvas.createCanvas(width, height);
    const context = canvas.getContext("2d");
    const imageData = context.createImageData(width, height);

    imageData.data.set(pixelData);
    context.putImageData(imageData, 0, 0);

    const writeStream = fs.createWriteStream(__dirname + output + ".png");
    const pngStream = canvas.pngStream();

    pngStream.on("data", function(chunk) {
        writeStream.write(chunk);
    });

    pngStream.on("end", function() {
        console.log("save png to", writeStream.path);
    });
}

function hexToRGBa (hex) {
    // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
    var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
    hex = hex.replace(shorthandRegex, function(m, r, g, b) {
        return r + r + g + g + b + b;
    });

    var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? [
        parseInt(result[1], 16),
        parseInt(result[2], 16),
        parseInt(result[3], 16),
        255
    ] : null;
}

module.exports = render;